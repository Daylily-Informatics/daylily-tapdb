"""
TAPDB EUID Configuration.

Enterprise Unique Identifier (EUID) configuration for TAPDB.
EUIDs are generated by database triggers using configured prefixes.

Prefix Tiers:
- CORE_PREFIXES: Required for TAPDB operation (GT, GX, GL)
- OPTIONAL_PREFIXES: Common domain types (WX, WSX, XX)
- Application prefixes: User-defined for specific domains
"""

from dataclasses import dataclass, field
from typing import Dict, Optional, Set


@dataclass
class EUIDConfig:
    """
    EUID prefix configuration.

    Core prefixes (always present):
        GT: generic_template
        GX: generic_instance (fallback)
        GL: generic_instance_lineage

    Optional prefixes (common domains):
        WX: workflow_instance
        WSX: workflow_step_instance
        XX: action_instance

    Application prefixes (user-defined):
        CX: container_instance
        MX: content_instance
        EX: equipment_instance
        etc.

    Usage:
        config = EUIDConfig()
        config.register_prefix("CX", "container_instance")
        config.register_prefix("MX", "content_instance")
    """

    # Core prefixes - required for TAPDB operation
    CORE_PREFIXES: Dict[str, str] = field(
        default_factory=lambda: {
            "GT": "generic_template",
            "GX": "generic_instance",
            "GL": "generic_instance_lineage",
        }
    )

    # Optional prefixes - common domain types
    OPTIONAL_PREFIXES: Dict[str, str] = field(
        default_factory=lambda: {
            "WX": "workflow_instance",
            "WSX": "workflow_step_instance",
            "XX": "action_instance",
        }
    )

    # Application prefixes - user-defined
    application_prefixes: Dict[str, str] = field(default_factory=dict)

    def __post_init__(self):
        """Validate no prefix collisions."""
        self._validate_no_collisions()

    def _validate_no_collisions(self) -> None:
        """Ensure no prefix is used twice."""
        all_prefixes = list(self.CORE_PREFIXES.keys())
        all_prefixes.extend(self.OPTIONAL_PREFIXES.keys())
        all_prefixes.extend(self.application_prefixes.keys())

        seen: Set[str] = set()
        for prefix in all_prefixes:
            if prefix in seen:
                raise ValueError(f"Duplicate EUID prefix: {prefix}")
            seen.add(prefix)

    def register_prefix(self, prefix: str, discriminator: str) -> None:
        """
        Register an application-specific EUID prefix.

        Args:
            prefix: The EUID prefix (e.g., "CX")
            discriminator: The polymorphic_discriminator value
                (e.g., "container_instance")

        Raises:
            ValueError: If prefix already exists
        """
        if prefix in self.CORE_PREFIXES:
            raise ValueError(f"Cannot override core prefix: {prefix}")
        if prefix in self.OPTIONAL_PREFIXES:
            raise ValueError(f"Cannot override optional prefix: {prefix}")
        if prefix in self.application_prefixes:
            raise ValueError(f"Prefix already registered: {prefix}")

        self.application_prefixes[prefix] = discriminator

    def get_prefix_for_discriminator(self, discriminator: str) -> Optional[str]:
        """
        Get the EUID prefix for a polymorphic discriminator.

        Args:
            discriminator: The polymorphic_discriminator value

        Returns:
            The EUID prefix, or None if not found
        """
        # Check all prefix maps
        for prefix, disc in self.CORE_PREFIXES.items():
            if disc == discriminator:
                return prefix
        for prefix, disc in self.OPTIONAL_PREFIXES.items():
            if disc == discriminator:
                return prefix
        for prefix, disc in self.application_prefixes.items():
            if disc == discriminator:
                return prefix
        return None

    def get_all_prefixes(self) -> Dict[str, str]:
        """Get all registered prefixes (core + optional + application)."""
        result = dict(self.CORE_PREFIXES)
        result.update(self.OPTIONAL_PREFIXES)
        result.update(self.application_prefixes)
        return result

    def to_sql_case_statement(self) -> str:
        """
        Generate SQL CASE statement for EUID trigger.

        Returns:
            SQL CASE statement mapping discriminators to prefixes
        """
        lines = ["CASE NEW.polymorphic_discriminator"]
        for prefix, discriminator in self.get_all_prefixes().items():
            lines.append(f"    WHEN '{discriminator}' THEN '{prefix}'")
        lines.append("    ELSE 'GX'")  # Fallback to generic instance prefix
        lines.append("END")
        return "\n".join(lines)
